import type { ChatMessage, ToolCallRecord } from '@/types/architect'

interface ToolResults {
  analyze_orbit?: Record<string, unknown>
  compute_power_budget?: Record<string, unknown>
  compute_ground_passes?: Record<string, unknown>
  predict_lifetime?: Record<string, unknown>
  analyze_payload?: Record<string, unknown>
}

function extractToolResults(messages: ChatMessage[]): ToolResults {
  const results: ToolResults = {}
  // Walk in reverse to get latest result per tool
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i]
    if (msg.role !== 'assistant' || !msg.toolCalls) continue
    for (const tc of msg.toolCalls) {
      if (tc.status !== 'complete' || !tc.output) continue
      const name = tc.toolName as keyof ToolResults
      if (name in results) continue // already have latest
      if (name === 'analyze_orbit' || name === 'compute_power_budget' ||
          name === 'compute_ground_passes' || name === 'predict_lifetime' ||
          name === 'analyze_payload') {
        results[name] = tc.output as Record<string, unknown>
      }
    }
  }
  return results
}

function extractUserPrompt(messages: ChatMessage[]): string {
  const first = messages.find((m) => m.role === 'user')
  return first?.content || ''
}

function extractAssistantText(messages: ChatMessage[]): string {
  // Get the last non-empty assistant text (the final analysis)
  for (let i = messages.length - 1; i >= 0; i--) {
    const msg = messages[i]
    if (msg.role === 'assistant' && msg.content && msg.content.length > 50) {
      return msg.content
    }
  }
  return ''
}

export async function generateArchitectReport(messages: ChatMessage[]): Promise<void> {
  const { jsPDF } = await import('jspdf')
  const autoTableModule = await import('jspdf-autotable')
  const autoTable = autoTableModule.default

  const doc = new jsPDF('p', 'mm', 'a4')
  const pageWidth = doc.internal.pageSize.getWidth()
  const margin = 15
  const contentWidth = pageWidth - 2 * margin
  let y = margin

  const BLUE = [59, 130, 246] as const
  const CYAN = [34, 211, 238] as const
  const GRAY = [107, 114, 128] as const
  const DARK = [51, 51, 51] as const

  // ─── Helpers ───

  function addFooter() {
    const pageHeight = doc.internal.pageSize.getHeight()
    doc.setFontSize(7)
    doc.setFont('helvetica', 'normal')
    doc.setTextColor(GRAY[0], GRAY[1], GRAY[2])
    doc.text(
      'Generated by OrbitForge \u2014 North Star AI Solutions',
      margin,
      pageHeight - 8
    )
    doc.text('orbit-forge.vercel.app', margin, pageHeight - 4)
    doc.text(
      `Page ${doc.getNumberOfPages()}`,
      pageWidth - margin,
      pageHeight - 8,
      { align: 'right' }
    )
  }

  function checkPageBreak(neededSpace: number) {
    const pageHeight = doc.internal.pageSize.getHeight()
    if (y + neededSpace > pageHeight - 20) {
      addFooter()
      doc.addPage()
      y = margin
    }
  }

  function addSectionTitle(title: string) {
    checkPageBreak(12)
    doc.setFillColor(CYAN[0], CYAN[1], CYAN[2])
    doc.rect(margin, y, contentWidth, 0.5, 'F')
    y += 3
    doc.setFontSize(11)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(CYAN[0], CYAN[1], CYAN[2])
    doc.text(title.toUpperCase(), margin, y + 4)
    y += 10
    doc.setTextColor(DARK[0], DARK[1], DARK[2])
  }

  function addTable(headers: string[], rows: string[][]) {
    checkPageBreak(20)
    autoTable(doc, {
      startY: y,
      head: [headers],
      body: rows,
      margin: { left: margin, right: margin },
      styles: {
        fontSize: 8,
        cellPadding: 2,
        font: 'courier',
        textColor: [51, 51, 51],
        lineColor: [220, 220, 220],
        lineWidth: 0.1,
      },
      headStyles: {
        fillColor: [34, 211, 238],
        textColor: [10, 10, 30],
        font: 'helvetica',
        fontStyle: 'bold',
        fontSize: 8,
      },
      alternateRowStyles: {
        fillColor: [248, 249, 250],
      },
      didDrawPage: () => {
        addFooter()
      },
    })
    y = (doc as any).lastAutoTable.finalY + 8
  }

  function addKeyValue(label: string, value: string) {
    checkPageBreak(6)
    doc.setFontSize(8)
    doc.setFont('helvetica', 'bold')
    doc.setTextColor(GRAY[0], GRAY[1], GRAY[2])
    doc.text(label + ':', margin, y)
    doc.setFont('courier', 'normal')
    doc.setTextColor(DARK[0], DARK[1], DARK[2])
    doc.text(value, margin + 50, y)
    y += 5
  }

  function addWrappedText(text: string, fontSize = 8) {
    checkPageBreak(10)
    doc.setFontSize(fontSize)
    doc.setFont('helvetica', 'normal')
    doc.setTextColor(DARK[0], DARK[1], DARK[2])
    const lines = doc.splitTextToSize(text, contentWidth)
    for (const line of lines) {
      checkPageBreak(5)
      doc.text(line, margin, y)
      y += 4
    }
    y += 2
  }

  // ─── Extract Data ───

  const results = extractToolResults(messages)
  const userPrompt = extractUserPrompt(messages)
  const assistantText = extractAssistantText(messages)

  // ─── 1. Header ───

  doc.setFillColor(CYAN[0], CYAN[1], CYAN[2])
  doc.rect(margin, margin, 8, 8, 'F')
  doc.setFontSize(14)
  doc.setFont('helvetica', 'bold')
  doc.setTextColor(DARK[0], DARK[1], DARK[2])
  doc.text('ORBITFORGE', margin + 12, margin + 6)
  doc.setFontSize(8)
  doc.setFont('helvetica', 'normal')
  doc.setTextColor(GRAY[0], GRAY[1], GRAY[2])
  doc.text('Mission Architect Report', margin + 12, margin + 10)
  y = margin + 16

  doc.setFontSize(16)
  doc.setFont('helvetica', 'bold')
  doc.setTextColor(DARK[0], DARK[1], DARK[2])
  doc.text('Mission Analysis Report', margin, y + 4)
  y += 8
  doc.setFontSize(9)
  doc.setFont('helvetica', 'normal')
  doc.setTextColor(GRAY[0], GRAY[1], GRAY[2])
  doc.text('Generated by OrbitForge Mission Architect', margin, y)
  y += 5
  doc.text('North Star AI Solutions', margin, y)
  y += 5
  doc.text(`${new Date().toISOString().slice(0, 19)} UTC`, margin, y)
  y += 10

  // ─── 2. Mission Description ───

  if (userPrompt) {
    addSectionTitle('Mission Description')
    addWrappedText(userPrompt, 9)
  }

  // ─── 3. AI Assumptions ───

  // Extract assumptions from first assistant message
  const firstAssistant = messages.find((m) => m.role === 'assistant' && m.content)
  if (firstAssistant?.content) {
    const content = firstAssistant.content
    // Try to extract an assumptions section or initial analysis
    const assumptionsMatch = content.match(/(?:assum|default|I'll use|using|parameter)[^\n]*(?:\n[^\n]*){0,10}/i)
    if (assumptionsMatch) {
      addSectionTitle('AI Assumptions')
      addWrappedText(assumptionsMatch[0].replace(/[*#]/g, '').trim())
    }
  }

  // ─── 4. Orbit Characteristics ───

  if (results.analyze_orbit) {
    const r = results.analyze_orbit
    addSectionTitle('Orbit Characteristics')
    addTable(
      ['Parameter', 'Value'],
      [
        ['Altitude', `${r.altitude_km} km`],
        ['Inclination', `${r.inclination_deg}\u00B0`],
        ['Eccentricity', `${r.eccentricity}`],
        ['Orbital Period', `${r.period_minutes} min`],
        ['Perigee Altitude', `${r.perigee_alt_km} km`],
        ['Apogee Altitude', `${r.apogee_alt_km} km`],
        ['Velocity (Perigee)', `${r.velocity_perigee_kms} km/s`],
        ['Velocity (Apogee)', `${r.velocity_apogee_kms} km/s`],
        ['Eclipse Fraction', `${((r.eclipse_fraction as number) * 100).toFixed(1)}%`],
        ['Eclipse Duration', `${r.eclipse_duration_minutes} min`],
        ['Sunlight Duration', `${r.sunlight_duration_minutes} min`],
        ['Revolutions/Day', `${r.revolutions_per_day}`],
        ['RAAN Drift', `${r.raan_drift_deg_per_day}\u00B0/day`],
        ['Sun-Synchronous', r.is_sun_synchronous ? 'Yes' : 'No'],
        ...(r.sun_sync_ltan ? [['LTAN', `${r.sun_sync_ltan}`]] : []),
      ]
    )
  }

  // ─── 5. Payload Performance ───

  if (results.analyze_payload) {
    const r = results.analyze_payload
    const isEO = r.payload_type === 'earth-observation'

    addSectionTitle(isEO ? 'Payload Performance (Earth Observation)' : 'Payload Performance (SATCOM)')

    if (isEO) {
      const optics = r.optics as Record<string, unknown> | undefined
      addTable(
        ['Parameter', 'Value'],
        [
          ...(optics ? [
            ['Focal Length', `${optics.focal_length_mm} mm`],
            ['Aperture', `${optics.aperture_mm} mm`],
            ['Pixel Size', `${optics.pixel_size_um} \u03BCm`],
            ['F-Number', `f/${optics.f_number}`],
          ] : []),
          ['GSD (Nadir)', `${r.gsd_nadir_m} m`],
          ['GSD (Off-Nadir)', `${r.gsd_off_nadir_m} m`],
          ['Swath Width', `${r.swath_width_km} km`],
          ['FOV Cross-Track', `${r.fov_cross_track_deg}\u00B0`],
          ['SNR', `${r.snr}`],
          ['Daily Imaging Capacity', `${r.daily_imaging_capacity_km2} km\u00B2`],
          ['Revisit Time', `${r.revisit_time_days} days`],
          ['Data Volume/Orbit', `${r.data_volume_per_orbit_gb} GB`],
          ['Data Volume/Day', `${r.data_volume_per_day_gb} GB`],
          ['Storage Fill Days', `${r.storage_fill_days} days`],
        ]
      )
    } else {
      const rf = r.rf_config as Record<string, unknown> | undefined
      addTable(
        ['Parameter', 'Value'],
        [
          ...(rf ? [
            ['Downlink Freq', `${rf.downlink_freq_ghz} GHz`],
            ['Sat Antenna Dia', `${rf.sat_antenna_dia_m} m`],
            ['Sat TX Power', `${rf.sat_tx_power_w} W`],
            ['GS Antenna Dia', `${rf.gs_antenna_dia_m} m`],
          ] : []),
          ['Sat Antenna Gain', `${r.sat_antenna_gain_dbi} dBi`],
          ['GS Antenna Gain', `${r.gs_antenna_gain_dbi} dBi`],
          ['EIRP', `${r.eirp_dbw} dBW`],
          ['Free-Space Path Loss', `${r.free_space_path_loss_db} dB`],
          ['Link Margin', `${r.link_margin_db} dB`],
          ['Max Data Rate', `${r.max_data_rate_mbps} Mbps`],
          ['Beam Footprint', `${r.beam_footprint_km} km`],
          ['Data Volume/Pass', `${r.data_volume_per_pass_gb} GB`],
          ['Data Volume/Day', `${r.data_volume_per_day_gb} GB`],
        ]
      )
    }
  }

  // ─── 6. Power Budget ───

  if (results.compute_power_budget) {
    const r = results.compute_power_budget
    const sc = r.spacecraft_config as Record<string, unknown> | undefined
    addSectionTitle('Power Budget')

    if (sc) {
      addKeyValue('CubeSat Size', `${sc.size}`)
      addKeyValue('Mass', `${sc.mass_kg} kg`)
      addKeyValue('Solar Panels', `${sc.solar_panel_config} (${sc.solar_panel_area_m2} m\u00B2)`)
      addKeyValue('Pointing Mode', `${sc.pointing_mode}`)
      addKeyValue('Battery', `${sc.battery_capacity_wh} Wh`)
      y += 2
    }

    addTable(
      ['Metric', 'Value'],
      [
        ['Peak Solar Power', `${r.peak_solar_power_w} W`],
        ['Avg Generation (BOL)', `${r.avg_power_generation_w} W`],
        ['Avg Consumption', `${r.avg_power_consumption_w} W`],
        ['Power Margin', `${r.power_margin_percent}% (${r.margin_status})`],
        ['Battery DoD/Orbit', `${((r.battery_depth_of_discharge as number) * 100).toFixed(1)}% (${r.dod_status})`],
        ['Eclipse Fraction', `${((r.eclipse_fraction as number) * 100).toFixed(1)}%`],
        ['Eclipse Duration', `${r.eclipse_duration_minutes} min`],
        ['EOL Generation', `${r.eol_power_generation_w} W`],
        ['EOL Margin', `${r.eol_margin_percent}% (${r.eol_margin_status})`],
        ['Design Lifetime', `${r.lifetime_years} years`],
      ]
    )
  }

  // ─── 7. Ground Communications ───

  if (results.compute_ground_passes) {
    const r = results.compute_ground_passes
    addSectionTitle('Ground Communications')

    const stations = r.ground_stations as Array<Record<string, unknown>> | undefined
    if (stations) {
      addTable(
        ['Station', 'Latitude', 'Longitude'],
        stations.map((s) => [
          `${s.name}`,
          `${(s.lat as number).toFixed(2)}\u00B0`,
          `${(s.lon as number).toFixed(2)}\u00B0`,
        ])
      )
    }

    addTable(
      ['Metric', 'Value'],
      [
        ['Simulation Duration', `${r.simulation_days} day(s)`],
        ['Total Passes', `${r.total_passes}`],
        ['Passes/Day', `${r.passes_per_day}`],
        ['Avg Pass Duration', `${r.avg_pass_duration_minutes} min`],
        ['Max Gap', `${r.max_gap_hours} hrs`],
        ['Daily Contact Time', `${r.daily_contact_time_minutes} min`],
        ['Daily Data Throughput', `${r.daily_data_throughput_mb} MB`],
        ['Data Rate', `${r.data_rate_kbps} kbps`],
      ]
    )
  }

  // ─── 8. Orbital Lifetime & Compliance ───

  if (results.predict_lifetime) {
    const r = results.predict_lifetime
    addSectionTitle('Orbital Lifetime & Compliance')

    addTable(
      ['Parameter', 'Value'],
      [
        ['Altitude', `${r.altitude_km} km`],
        ['Spacecraft Size', `${r.spacecraft_size}`],
        ['Spacecraft Mass', `${r.spacecraft_mass_kg} kg`],
        ['Cross-Section', `${r.cross_section_m2} m\u00B2`],
        ['Solar Activity', `${r.solar_activity}`],
        ['Natural Lifetime', `${r.lifetime_years} years (${r.lifetime_days} days)`],
        ['25-Year Rule (IADC)', (r.compliant_25_year_rule as boolean) ? 'COMPLIANT' : 'NON-COMPLIANT'],
        ['5-Year Rule (FCC)', (r.compliant_fcc_5_year_rule as boolean) ? 'COMPLIANT' : 'NON-COMPLIANT'],
        ['Deorbit \u0394V', `${r.deorbit_delta_v_ms} m/s`],
      ]
    )

    if (r.recommendation) {
      checkPageBreak(10)
      doc.setFontSize(8)
      doc.setFont('helvetica', 'italic')
      doc.setTextColor(GRAY[0], GRAY[1], GRAY[2])
      const lines = doc.splitTextToSize(`Recommendation: ${r.recommendation}`, contentWidth)
      doc.text(lines, margin, y)
      y += lines.length * 4 + 4
    }
  }

  // ─── 9 & 10. Recommendations (from AI final text) ───

  if (assistantText) {
    // Strip markdown formatting for PDF
    const cleaned = assistantText.replace(/[*#`]/g, '').trim()
    if (cleaned.length > 100) {
      addSectionTitle('Analysis & Recommendations')
      addWrappedText(cleaned)
    }
  }

  // Footer on last page
  addFooter()

  // Save
  doc.save('Mission_Architect_Report.pdf')
}
